#!/usr/bin/env bash
set -euo pipefail
trap 'logger -p error -t "S1_DEPLOY" "[$(date)] Ошибка в строке $LINENO: команда \"$BASH_COMMAND\""' ERR



#
# Отправляет проект на сервер, публикует его
# Выполняем post-deploy скрипт
#



##
##  ВАЖНО:
##
##  На сервере папка назначения заранее должна иметь права записи для пользователя от которого происходит деплой.
##  Что-то типа такого на сервере:
##      sudo mkdir -p /var/www/${DOMAIN}
##      sudo chown -R ${USER}:www-data /var/www/${DOMAIN}
##      sudo chmod -R 770 /var/www/${DOMAIN}
##
##
##  ВАЖНО:
##
##  Чтобы всё нормально работало нужно сгенерировать RSA ключи и отправить на сервер чтоы ssh b rsync не задавали глупых вопросов.
##
##  Делается это примерно так:
##
##  1. Сгенерировать ключ на строне клиента, если его ещё нет:
##
##      # RSA (обычно достаточно) или ed25519 (рекомендуется, короче и безопаснее)
##      ssh-keygen -t ed25519 -C "your@mail.example" -f ~/.ssh/id_ed25519
##      # или для RSA
##      # ssh-keygen -t rsa -b 4096 -C "your@mail.example" -f ~/.ssh/id_rsa
##
##  passphrase ключа лучше не задавать, инае єто не будет иметь смысла.
##
##
##  2. Копируем публичный ключ на сервер
##  Вариант проще: ssh-copy-id
##
##      # обычный порт 22
##      ssh-copy-id -i ~/.ssh/id_ed25519.pub user@server.example.com
##      # если нестандартный порт, например 2222
##      ssh-copy-id -i ~/.ssh/id_ed25519.pub -p 2222 user@server.example.com
##
##  ssh-copy-id автоматически создаст ~/.ssh и добавит ключ в ~/.ssh/authorized_keys с правильными правами.
##
##  3. Проверить подключение с клиента:
##
##      # простой тест
##      ssh -i ~/.ssh/id_ed25519 -p 2222 user@server.example.com
##      # если стандартный ключ ~/.ssh/id_ed25519 используется по умолчанию:
##      ssh -p 2222 user@server.example.com
##
##  Если всё настроено верно — подключение выполнится без запроса пароля
##  (либо запросит passphrase ключа, если вы его задали).
##



# ==============================
# Настройки деплоя
# ==============================
DOMAIN="my.domain.com"
SSH_PORT="22"
SSH_KEY="${HOME}/.ssh/id_ed25519"   # или "" если ключ не нужен. ВАЖНО: путь должен быть БЕЗ пробелов
CLOUD_HOST="${USER}@${DOMAIN}"
CLOUD_PATH="/var/www/${DOMAIN}"
CLOUD_URL="${CLOUD_HOST}:${CLOUD_PATH}"
CLOUD_RUN="organize_folders.sh"



# --- что деплоим ---
DEPLOY=(
    "app"
    "billing"
    "config"
    "public"
    "vendor"
    "composer.json"
    "composer.lock"
    ".htaccess"
    "organize_folders.sh"
)

# --- что исключаем ---
EXCLUDES=(
    ".git"
    ".gitignore"
    "storage/*"
    "public/uploads/*"
    "public/phpinfo.php"
)



# ==============================
# Формируем параметры rsync
# ==============================

# Формируем список исключений для rsync
EXCLUDE_PARAMS=()
for excl in "${EXCLUDES[@]}"; do
    EXCLUDE_PARAMS+=(--exclude="$excl")
done

# Формируем список путей для копирования
DEPLOY_PATHS=()
for item in "${DEPLOY[@]}"; do
    DEPLOY_PATHS+=("./${item}")
done



# ==============================
# Формируем rsh для rsync и ssh
# ==============================
SSH_CMD=(ssh)
[[ -n "${SSH_KEY}" ]] && SSH_CMD+=(-i "${SSH_KEY}")
SSH_CMD+=(-p "${SSH_PORT}")



# ==============================
# Запускаем rsync
# ==============================
echo "→ Deploying..."
rsync \
    --rsh="${SSH_CMD[*]}" \
    --archive \
    --human-readable \
    --verbose \
    --progress \
    --delete \
    "${EXCLUDE_PARAMS[@]}" \
    "${DEPLOY_PATHS[@]}" \
    "${CLOUD_URL}/"


# ==============================
# Post-deploy на сервере
# ==============================
echo "Выполняем post-deploy скрипт..."
"${SSH_CMD[@]}" "${CLOUD_HOST}" "bash -l -c 'bash ${CLOUD_PATH}/${CLOUD_RUN}'"
echo "...end post-deploy."
echo "→ Deploy completed successfully!"




##
##   Подсказки по rsync
##
## --human-readable        Выводит размеры файлов в читаемом виде (1K, 2.3M, 1G) вместо байт.
## --verbose               Подробный вывод: показывает, что копируется, создаётся, удаляется.
## --progress              Показывает прогресс копирования каждого файла (скорость, % выполнения).
##
## Архивирование и рекурсия
##
## --archive (-a)          Режим архивации. Это сочетание нескольких опций:
##                         -r → рекурсивно копирует каталоги
##                         -l → копирует символические ссылки как ссылки
##                         -p → сохраняет права доступа
##                         -t → сохраняет времена модификации
##                         -g → сохраняет группу
##                         -o → сохраняет владельца
##                         -D → сохраняет устройства и файлы специального типа
##
## --recursive (-r)        Рекурсивное копирование директорий.
##                         Примечание: при --archive рекурсия уже включена, так что --recursive тут дублирует.
##
## Времена, права, владельцы
##
## --times (-t)            → сохраняет время модификации файлов
## --perms (-p)            → сохраняет права файлов
## --owner (-o)            → сохраняет владельца файла (нужны права root на сервере)
## --xattrs                → сохраняет расширенные атрибуты файлов (SELinux, ACL и пр.)
## --acls                  → сохраняет ACL (списки контроля доступа)
## --atimes                → сохраняет время последнего доступа
## --executability         → сохраняет флаг выполнения (+x)
##
## Ссылки
##
## --links (-l)            → сохраняет символические ссылки как ссылки
## --hard-links            → сохраняет жёсткие ссылки
##
## Удаление
##
## --delete                Удаляет на сервере файлы и папки, которых больше нет в исходной директории.
##
