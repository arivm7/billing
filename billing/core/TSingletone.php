<?php


namespace billing\core;


/**
 * Если вам нужно поддерживать несколько типов синглтонов в вашем приложении,
 * вы можете определить основные функции Singleton в базовом классе,
 * перемещая фактическую бизнес -логику (например, журнал) в подклассы.
 */
trait TSingletone
{


    protected static array $instances  = [];



    /**
     * Конструктор Синглтона не должен быть публичным.
     * Тем не менее, это также не может быть частным, если мы хотим разрешить подклассу.
     */
    private function __construct() {}



    /**
     * Клонирование и десериализация синглтонов запрещены.
     */
    private function __clone() {}



    public function __wakeup() {
        throw new \Exception("Cannot unserialize Singleton");
    }



    /**
     * Фактический экземпляр Синглтона почти всегда находится в статическом поле.
     * В этом случае статическое поле представляет собой массив,
     * где каждый подкласс Синглтона хранит свой собственный экземпляр.
     * @return object
     */
    public static function instance():object {
        /**
         * Получает имя текущего вызывающего класса.
         * Это важно для поддержки наследования — чтобы каждый подкласс имел свой собственный "единственный" экземпляр.
         */
        $subclass = static::class;
        // Проверяет, существует ли уже объект данного класса в массиве self::$instances.
        if (!isset(self::$instances[$subclass])) {
            /**
             * Если нет — создаёт новый объект new static() и сохраняет его в массив.
             * new static() используется (в отличие от new self()), чтобы можно было
             * правильно создать экземпляр подкласса, если метод вызывается из него.
             *
             * Обратите внимание, что здесь мы используем ключевое слово «static» вместо имени класса.
             * В данном контексте ключевое слово «static» означает «имя текущего класса».
             * Эта деталь важна, поскольку при вызове метода в подклассе мы хотим,
             * чтобы экземпляр этого подкласса был создан здесь.
             */
            self::$instances[$subclass] = new static();
        }
        // Возвращает единственный экземпляр объекта для этого класса.
        return self::$instances[$subclass];
    }



    /**
     * Просто обёртка для instance()
     * @return object
     */
    public static function getInstance(): object {
        return static::instance();
    }
    


}